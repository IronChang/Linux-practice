多线程：
	线程概念：
		1、传统操作系统中，PCB就是进程，线程TCB；但是linux下，因为线程是通过进程的PCB模拟实现的，因此linux下的PCB实际就是
		一个线程，并且这些线程公用同一块虚拟地址空间，因此也把linux的线程也叫轻量级进程，相较于PCB更加轻量化
	    2、PCb是一个轻量级进程(线程)，进程是一个线程组
		3、linux下，线程是CPU调度的基本单位，而进程是资源分配的基本单位
		4、线程是在进程内部(地址空间内部)运行的
		5、一个进程内面可能有多个线程，linux下所有的进程都是轻量级进程
		6、进程强调的是独立性，而线程是强调共享
		
		线程的优点
			1、创建一个新线程的代价要比创建一个新进程小得多
			2、与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少
			3、线程占用的资源要比进程少很多
			4、能够充分利用多处理器
			5、在等待慢速I/O操作结束的同时，程序可以执行其他的计算任务
			6、计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现
			7、I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以等待不同的I/O操作
		进程的缺点
			1、创建过多，导致性能损失
			2、健壮性降低，
			3、缺乏访问控制
			4、编写难度提高
		线程的异常
			1、单线程如果出现除零、野指针问题导致线程崩溃，进程也会随之崩溃
			2、线程是进程的执行分支，线程出异常，就类似于进程出异常，进而触发信号机制，终止进程，
				进程终止，那么进程内其他线程也就随即退出
		线程用途
		
		进程和线程
			线程共享进程数据，但是也拥有自己的一部分数据
				1、线程ID、优先级、errno、信号屏蔽字
				2、栈结构---会产生临时变量，会调用函数
				3、独立的硬件上下文---要进行调度--寄存器
			线程共享下列资源
				1、文件描述符表
				2、每种信号处理方式
				3、当前工作目录
				4、用户id和组id
				5、虚拟地址空间(代码段+数据段)
	线程控制：操作系统并没有给用户直接提供创建一个线程的接口，因此有大佬就封装了一套线程库，用于线程的控制
		POSIX线程库：
			在使用库函数时，必须包含头文件<pthread.h>,编译的时候使用编译命令“-lpthread”
		线程创建：
			int pthread_create(pthread_t *tid,pthread_attr_t *attr,void*(*start_routine)(void*),void *arg)
			tid:线程的ID(线程地址空间的首地址)
			attr：设置线程的属性，attr为NULL表示使用默认属性
			start_routine：是一个函数地址，线程启动后表示要执行的函数
			arg：传给线程启动函数的参数
			返回值：成功返回0，失败返回错误码
		创建时的错误检查：
			传统函数成功返回0，失败时返回-1，并且对全局变量errno赋值以示是错误
			pthreads函数出错时不会设置errno全局变量(而大部分POSIX函数会这样做)而是将错误代码通过返回值直接返回
			pthreads同样提供了线程内部的errno变量，以支持其他适用errno的代码
			
			tid(用户态的线程ID)：指的是该线程的地址空间在进程虚拟地址空间中的首地址（通过库函数所创建的线程其新in描述存储在进程的虚拟地址空间中的共享区）
			pcb->pid:线程的轻量级进程ID，pcb->tgid：线程组就是进程ID---值1默认就等于主线程的pid
			ps -L：查看轻量级进程信息 LWP
			用户通过调用库函数(封装了PCB创建的系统接口等)创建了一个轻量级进程并且将创建的该轻量级进程的信息返回用户态经过封装存储起来，
			方便用户通过这些信息去操作内核中的轻量级进程，而在用户态态中存储这些信息线程的描述信息----用户态线程，通过内核中的轻量级进程来完成该线程的调度。
			用户态线程中存储轻量级进程的操作句柄
		线程终止：
			如果需要终止某一个线程而不是整个进程，有以下三种方法：
			1、从线程函数进行return，这种方法对主线程不适用，从main函数调用return相当于调用exit()
			2、线程库提供的pthread_exit(void* retval)函数来通过调用结束
			3、一个线程可以通过调用pthread_cancel函数去终止同一个进程中的另外一个线程
			void pthread_exit(void *value_ptr):进程终止
			value_ptr：value_ptr不能指向一个局部变量。
			返回值：无返回值，
			
			int pthread_cancel(pthread_t thread)；：取消一个执行中的进程
			参数：thread：线程ID
			返回值：成功返回0，失败返回错误码
			
			注意：主线程退出将不会导致进程退出，会成为僵尸线程；
			
		线程等待：
			原因：已经退出的线程，其空间没有被释放，仍然在进程的地址空间中，
			      创建新的线程不会复用刚才退出线程的地址空间，造成空间浪费
			int pthread_join(pthread_t thread,void **value_ptr) ： 等待线程结束，并且获取进程退出信息线程退出信息
			参数：thread：线程ID；value_ptr：指向一个指针，后者指向一个进程的返回值
			返回值：成功返回0，失败返回错误码：
			
			调用该函数的线程将挂起等待，知道id为thread的线程终止，thread线程会以不同的方法终止，通过pthread_join的到的终止状态
			也是不同的：
			1、如果thread通过return返回，value_ptr所指向的单元内面存放的是thread线程函数的返回值
			2、如果thread线程被别的线程调用pthread_ cancel异常终掉,value_ ptr所指向的单元里存放的是常数
            PTHREAD_ CANCELED。
			3、如果thread线程是自己调用pthread_exit终止的,value_ptr所指向的单元存放的是传给pthread_exit的参
            数。
			4、如果对thread线程的终止状态不感兴趣,可以传NULL给value_ ptr参数
			
		线程分离：
			原因：一个线程创建出来，默认在退出时是不会释放所用资源的，这是因为线程有一个属性--joinable
			处于joinable状态的线程，退出后不会自动释放所用资源。而将该属性改为detach属性，表示分离该线程。
			被分离后的线程，处于detach状态在退出后，会自动释放所有资源。(本分离的小县城没必要被等待，如果非要等待会报错获取不到返回值)
			
			int pthread_detach(pthread_t tid);修改线程的属性，谁调用都可以，自己调用或者其他人调用
			tid pthread_self(void) 获取调用线程的ID	
	线程安全：多个线程间对临界资源进行争抢访问而不会造成数据二义或者逻辑混乱.
		实现：同步、互斥
			同步：通过条件判断，实现线程对临界资源访问的时序合理性
			互斥：通过同一时间只有一个线程能访问临界资源来保证数据操作安全性
		互斥实现：
			读写锁mutex：对临界区进行加锁而不是对临界资源加锁
				读写锁其实就是一个只有0/1的计数，通过这个来保证对临界资源操作，但是前提是自身计数器0/1变换就要保证原子操作性
				在寄存器中开始就放一个0，然后寄存器与内存之间通过一个命令直接转换为1一步完成避免中途被打断
				为什么置为0，临界区中没有线程，这是来了一个线程进入，防止其他线程访问只允许该线程进入临界区
				pthread_mutex_t 互斥锁变量类型
				pthread_mutex_init(pthread_mutex_t *mutex,pthread_mutexattr_t *attr) --初始化互斥锁
				pthread_mutex_lock(pthread_mutex_t *mutex) --加锁(阻塞型)
				pthread_mutex_unlock(pthread_mutex_t *mutex) --解锁
				pthread_mutex_destroy(pthread_mutex_t *mutex) --销毁锁
				注意：如果进行了加锁，需要在任意有可能退出线程的地方都要进行解锁
			死锁：一般出现在使用多个锁的情况下：哲学家吃饭
 				产生的四个必要条件：
					互斥条件--锁同一时间只有一个线程能获取
					不可剥夺条件--我加的锁只有我能解锁
					请求与保持条件--拿着A锁请求B锁，若请求不到，则一直保持A的所有不释放
					环路等待条件
				预防：
					破坏必要条件(非阻塞加锁)
				避免：
					银行家算法--需要调研
		同步实现：
			条件变量：条件变量提供了一个等待队列和让一个线程等待与唤醒的功能
				条件变量并没有提供条件判断的功能，不基本判断什么时候线程该等待或者唤醒的功能
				需要用户自己去完成
				pthread_cond_t 条件变量类型
				pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *attr) --初始化条件变量
				pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex) --让一个线程阻塞，将PCB加入到阻塞队列
				其实现：解锁 --》休眠 --》唤醒时加锁
				pthread_cond_signal(pthread_cond_t *cond) --通过条件变量唤醒等待队列上等待的线程
				环形至少一个等待队列上的线程
				pthread_cond_destroy(pthread_cond_t *cond) --销毁条件变量
			注意事项：
				1、用户的条件判断需要使用while()去判断(被唤醒的多个线程，都可能在等待上锁，解锁后
				这是线程在不具备访问条件的情况下，加锁成功进行了资源访问)
				2、不同的角色要使用多个条件变量并且等待在不同的条件变量上，（防止唤醒错线程）
			
	线 程 池：
		应用场景：
			t = t1(创建线程时间)+t2(任务处理时间)+t3(线程销毁时间)
			t1 + t3 /t:若大量的任务处理总耗时中线程的创建和销毁占用了大量比例，就意味着资源、性能的浪费；
			在大量请求的峰值压力下，若每一个请求都创建一个线程，则有可能资源耗尽程序崩溃；
			
		线程池：
			提前创建一堆线程(有最大数量限制),以及一个线程安全的任务队列，当大量请求到来时，被添加到任务队列中
			而线程池中的线程不断的从任务队列中获取任务进行处理即可；
		线程池作用：
			1、避免大量线程的频繁创建和销毁所带来的时间成本
			2、避免峰值压力下的线程创建过多导致资源耗尽的风险
		线程池实现：
			一个以上的线程+线程安全的任务队列；用c++封装一个线程池类(固定数量线程的线程池)，
			向外提供简单的线程池操作接口；
			1.固定数量的线程 数量限制+初始化接口----创建线程时间
			2.线程安全队列
		
		任务类：
		typedef void(*TaskHandler)(int data);
		class ThreadTask{
		private:
			int _data;
			TaskHandler _handler;
		public:
			ThreadTask(int data,TaskHandler handler);
			void Run(){_handler(data);	
		}
		
		线程池类：
		class Threadpool{
			private:
				int thr_num;
				std::queue<ThreadTask> _task_queue;
				pthread_mutex_t _mutex;
				pthread_cond_t _cond_con;
				pthread_cond_t _cond_pro;
			public:
				Threadpool(int max_thr = MAX_THR):thr_num(max_thr);
				bool PoolInit()
				bool TaskPush(ThreadTask &tt)
		}
				
	

	生产者与消费者模型(设计模式)：
		1、支持忙闲不均
		2、支持并发
		3、如果消费者是1对1的话，那么就可以采用一个无锁队列，更加高效。
		4、才用队列先进先出的方式，多对多就要保持数据的安全性，要保持线程安全
		5、解耦合：数据的相互依赖程度就叫耦合
		生产者与生产者之间应该具备互斥关系/消费者与消费者之间应该具备互斥关系/生产者与消费者之间具备同步+互斥
		class BlockQueue//环形队列
		{
			std::queue<int> _queue;
			int _capacity;
			//保证线程安全
			pthread_cond_t _cond_productor;//保证数据操作合理性
			pthread_cond_t _cond_consumer;
			pthread_mutex_t _mutex;//保证互斥
			public:
			BlockQueue();
			~BlockQueue();
			bool QueuePush(int &data);
			bool QueuePop(int &data);
		};	
	线程安全到单例模式：
		是一种典型的设计模式，是大佬们针对典型场景而设计出的解决方案，其中单例模式，指的是一个对象/资源只能被实例化
		加载一次
	线程安全单例模式实现方式：饿汉和懒汉
		饿汉：所用的资源加载/对象实例化都放在程序的初始化阶段，接下来在个线程中直接使用即可
		优点：资源直接加载，因而运行时性能能较高以及比较流畅
		缺点：将当前不用的资源也加载到了内存当中，因此资源消耗较大初始化消耗时间较长
		class Test
		{
			private:
				static int data;//静态成员具有不属于哪一个具体的对象，是该类实例化对象所共享
			public int* get_instance()
			{
				return &data;
			}
		}
		懒汉(使用的比较多)：资源并不在程序初始化阶段全部加载/初始化，等到需要的时候才去判断来加载/初始化资源
		优点：初始化速度较快，在运行阶段使用的时候也只是加载一次
		class Test
		{
			private:
				volatile static int *data;		1.实现最基本的单例模式
			public:						   		2.防止编译器过度优化
				int* get_instance()		   		3.防止初始化加载过程线程安全
				{								4.尽可能避免锁冲突
					if(data == NULL)
					{
					mutex.lock();					   
					if(data == NULL)
					{
						data = (int*)malloc(4);
						return data;
					}
					mutex.unlock();
					}
					return data;
				}
		};
		
信号量(POSIX标准)：实现线程、继承间的同步互斥
	实现进程是用的是全局变量，实现线程时申请一个共享内存实现一个计数器
	本质：计数器+等待队列+等待与唤醒功能接口
	信号量实现同步：通过自身计数器进行资源计数，对临界资源访问之前先访问信号量，通过计数判断是否有资源能访问
	，若不能访问-计数<0，则等待并且计数-1,此时计数个数就是等待的进/线程数量;若可以访问-计数>0，则计数-1，直接访问；
	其他线程促使条件满足和，则判断若计数>0，计数+1，否则若计数<0,则唤醒一个等待队列上的线程，并且计数+1；
	信号量实现互斥：只需要将计数器维持在0/1之间就可以实现互斥；
	int sem_init(sem_t *sem,int pshared,unsigned int value);---初始化信号量  
	pshared:0表示线程间共享，非零表示进程间共享
	value：信号量的初始值
	int sem_destroy(sem_t 8sem)；---销毁信号量
	int sem_wait(sem_t *sem);---等待信号量，会将信号量的值-1；条件判断若计数<0，则-1阻塞，否则-1立即返回；阻塞性加锁
	int sem_post(sem_t *sem); ---发布信号量，唤醒等待队列上面的线程。表示资源使用完毕，可以归还信号量值+1
	
	
	
	
课后调研：
	锁的种类-------应用场景
	线程池的种类------应用场景
	银行家算法
	
	
	
	
	
	
	