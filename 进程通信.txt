进程通信ipc：操作系统为用户提供几种进程间通信方式
    为什么要给用户提供ipc方式：
		因为进程的独立性，每一个进程只能访问自己的虚拟地址空间，进程之间无法直接沟通。需要操作系统提供某些媒介
	通信场景：
		数据传输/数据共享/进程控制
	通信方式：
		管道/共享内存/消息队列/信号量
	System V标准的进程间通信方式(只用于LInux中)：
		共享内存/消息队列/信号量	
	Posix标准：标准库的标准	
	
管道:内核空间中的一块缓冲区(内核中),多个进程访问同一块缓冲器来实现通信。
		匿名管道(没有标识符)：只能用于有亲缘关系的进程，必须在子进程创建之前创建
		匿名管道创建：
			一个进程通过操作系统在内核中创建一个管道，并且返回管道的操作句柄，但是由于这块缓冲区没有标识符，只能通过操作句柄进行访问，所以只能有创建者自己操作；
			通过子进程复制父进程的方式获取到一个管道的操作句柄，进而访问同一块缓冲区
		管道操作句柄：两个文件描述符因为是一个(半双工通信)，一个读数据，一个写数据；
		因为是半双工通信，可以选择方向的单向通信
		
		#include<unistd.h>
		
		int pipe(int pipefd[2])-------int piprfd[2]创建一个管道，返回两个操作句柄；输出型参数
		pipefd[0]---从管道中读数据
		pipefd[1]---想管道中写数据
		成功返回0，失败返回-1，设置errno
		
		读写性质：
			1、当管道中没有数据时，则read读出时，会阻塞
			2、当管道中数据写满时，write会阻塞，直到有数据出去
			3、若管道所有写端关闭，则read读完数据后不会阻塞，并且返回0
			4、当所有的读断关闭时，则write写入时会触发数据异常
			5、当写入的数据量不大于PIPE_BUF时，linux会保证写入的原子性
			6、当写入的数据量大于PIPE_BUF时，linux将不会保证写入的原子性
			7、PIPE_BUF = 4096字节 = 4k
			8、原子性：这个操作不会被打断
			9、管道自带同步与互斥
			10、同步：访问的时序合理性
			11、互斥：同一时间，只有一个执行流，能够操作数据(临界资源)。保证数据操作安全性
			12、多进程共享的内存资源叫做临界资源 、访问临界资源的代码叫做临界区
		命名管道：
			内核中的这块缓冲区具有标识符，标识符是一个可见文件系统的管道文件:filename.fifo。
			
			打开特性：
				1、可以用同一主机，任何进程之间通信
				2、若文件以只读的方式打开，则会阻塞直到文件被其他进程以写打开
				3、若文件以只写的方式打开，则会阻塞直到文件被其他进程以读打开
				4、
		管道文件类型： P --- 管道文件
			
		创建命名管道文件:只是创建了一个管道文件，但是并没有在你内核中创建缓冲区(避免空间浪费,打开管道文件时，才开辟空间)
			int mkfifo(const char* pathname，mode_t mode)
			返回值：成功返回0，失败返回-1
			pathname：管道文件路径名称
			mode：管道文件的操作权限
						
		命名管道和匿名管道的区别：
			1、匿名管道有pipe函数创建打开
			2、命名管道有mkfifo函数创建，用open打开
			3、FIFO(命名管道)与pipe(匿名管道)之间唯一的区别就在于他们的创建和打开时方式不同，一旦成功后，便具有相同的语义
			4、管道的生命周期随进程，打开该缓冲区的进程数为0时，缓冲区会回收
			5、管道提供字节流服务，可整块可分开
			
共享内存：进程间的数据共享----最快的进程间通信方式
			没有自带进程同步与互斥
		
		实现原理：
			1、在物理内存中开辟一块空闲空间---这块空间在内核中具有标识
			2、将这块空间通过页表映射到自己的虚拟地址空间
			3、通过虚拟地址进行内存操作
			4、解除映射关系
			5、删除共享内存
		原理：
			共享内存相较于其他通信方式，在通信的过程中直接通过虚拟地址进行操作进而少
		    了两次内核态和用户态之间的数据拷贝所以说是最快的的通信方式
	创建共享内存	
		#include<sys/ipc.h>
		#include<sys/shm.h>
		int shmget(key_t key,size_t size,int shmflg) ---
		key:共享内存在内核中的标识，让不同进程通过同一个key打开同一个共享内存，如果key被设置为IPC_PRIVATE这块共享内存不共享，仅仅用于具有亲缘关系的进程间通信
		size:共享内存大小 实际大小为：PAGE_SIZE的整数倍
		shmflg:共享内存的权限标志位(同read相同) IPC_CREAT、IPC_EXCL搭配使用,还有操作权限mode
		成功返回：共享内存的操作句柄，失败返回：-1
		
	了解#include<sys/types.h>
		#include<sys/ipc.h>
		key_t ftok(const char *pathname,int proj_id)-----计算key值得
		原理：去文件inode节点号取出一部分，将proj_id取出一部分。组合出一个key值
		pathname：固定文件名
		proj——id：的id
		缺点：文件改变，或proj_id改变，那么key不一样，那个共享内存就不一样了
		，如果删除文件，那么该共享内存只能自己访问。	
		
	查看共享内存：
		-ipcs 查看进程间通信方式
		-ipcs -m 查看共享内存
	
	建立映射关系
		#include<sys/types.h>
		#incldue<sys/shm.h>	
		void *shmat(int shmid,cosnt void* shmaddr,int shmflg)
		shmid：共享内存操作句柄
		shmaddr：要把共享内存要映射的虚拟地址，一般置NULL让操作系统自己去选择
		shmflg：给0默认任何操作；对该共享内存一个有什么样操作 SHM_RDONLY。对应的在创建时对应的共享内存必须有相应的权限才可以设置
		返回值;映射首地址，失败：返回-1
	解除映射关系
		#include<sys/types.h>
		#incldue<sys/shm.h>	
		int shmdt(const void*shmaddr);
		shmaddr:映射首地址
	删除共享内存：
		#include<sys/ipc.h>
		#include<sys/shm.h>
		
		int shmctl(int shmid , int cmd,struct shmid_ds *buf)--对共享内存的控制
		shmid:操作句柄
		cmd：IPC_RMID删除共享内存，
		truct shmid_ds：对共享内存的描述信息
	注意：
		1、内核中创建队列当调用时，并不会立即删除，知道这块空间的虚拟连接数为0是才真正删除，但是从调用时刻往后这块共享内存空间
		会拒绝对其进行虚拟连接
		2、共享内存是覆盖式写入，而相对管道是追加写
		
消息队列：用于进程间数据块传输--限制了消息队列中所能防止的数据大小
		本质：内核中的一个优先级队列，多个进程通过向一个队列中放置节点或获取节点来实现通信
		原理：
			1、内核中创建队列
			2、向队列中添加节点
			3、从队列中获取节点
			4、删除消息队列
		创建队列：
			#include<sys/types.h>
			#include<sys/ipc.h>
			#include<sys/msg.h>			
			int msgget(key_t key,int msgflg)			
		添加节点：
			int msgsnd(int msqid, const void*msgp，size_t msgsz，int msgflg）
			msqid：消息队列操作句柄
			msgp：添加节点(结构体)
		获取节点：
			int msgrec
		删除消息队列：
			int msgctl
		特性：
			1、自带同步与互斥
			2、传输有类型的数据块
			3、数据不会粘连  -------  对应管道字节流服务(会粘连)
			4、生命周期随内核
信号量：用于实现进程间的同步与互斥
		互斥：通过同一时间对临界资源只有一个进程能够访问，实现数据的安全操作--数据访问安全性
		同步：通过一些条件的判断实现对临界资源的有序访问--数据访问合理性
		
		本质：自带同步与互斥
		
		P/V原语；p操作：对计数器进行判断，然后进行-1，若没有资源则等待
				 v操作：对计数进行+1，唤醒等待队列中挂起的进程	
		实现：
			互斥：通过一个只有0/1的计数器来实现
			互斥：通过一个状态标记临界资源的当前的访问状态；对临界资源进行访问之前先判断一下这个标记，若状态
			为可访问状态，则将这个状态修改为不可访问状态，软后再去访问数据，访问完毕之后再将状态修改为可访问状态
			同步：通过一个计数器以及等待与唤醒功能来实现
			同步：通过一个计数器对资源数量进行计数，当想要获取临界资源时，则先判断计数，是否有资源可供访问，若有
			则计数-1，获取一个资源进行操作，若没有资源，则进行等待，等到其他进程生产数据后计数器进行+1，然后唤醒得到的进程